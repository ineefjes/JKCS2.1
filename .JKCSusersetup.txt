#!/bin/bash
##########################################################################################
############################## USER SETUP ################################################
##########################################################################################

# CONTENT:
# USER SETUP
#   - Output style setup
#   - Paths declaration
#   - Default supercomputer setup
# ADVANCED USER SETUP
#   - program_ABC
#   - program_XTB
#   - program_G16
#   - program_PYTHON2 & program_PYTHON3
#   - program_GoodVibes
#   - SBATCHuseradd

##########################
### Output style setup ###			
##########################

# Do you want colorful output? [1/0]
Qcolours=1
# Do you want the program symbol? [1/0]
Qsymbol=1

#########################
### Paths declaration ###
#########################

# DO NOT USE ~/ SYMBOL. DEFINE FULL PATH. 
PATH_ABCluster="/projappl/hvehkama/kubeckaj/Apps/ABCluster-2.0-Linux/rigidmol-optimizer"
PATH_XTB="/projappl/hvehkama/kubeckaj/Apps/XTB6.0/"
PATH_GoodVibes="/projappl/hvehkama/kubeckaj/Apps/goodvibes/goodvibes/GoodVibes.py"
PATH_ORCA="/projappl/hvehkama/kubeckaj/Apps/ORCA/orca_4_0_1_2_linux_x86-64_openmpi202/orca"
PATH_G16="/appl/soft/chem/gaussian/G16RevC.01/"

# YOU CAN CALCULATE AT THE SMAE PLACE YOU ARE (./), OR YOU HAVE SOMEWHERE ELSE A TMP DIR 
WRKDIR="./"

###################################
### Default supercomputer setup ###
###################################

function echo_SCpartition {
  echo """######################################################
## MAXTASKS CPU NODES REQ.TIME  PARTITION MEMPERCPU ##
======================================================
ABC   NoC     1    1   72:00:00   small      4000mb
XTB   NoC     1    1   72:00:00   small      4000mb
G16   100     8    1   72:00:00   small      4000mb
ORCA  100     8    1   72:00:00   small      4000mb
CC    100     8    1   330:00:00  longrun    4000mb
-loc  1       1    1   -          -          4000mb
======================================================"""
}

##########################################################################################
########################## ADVANCED USER SETUP ###########################################
##########################################################################################

##########################################################################################
# ABCluster script paths: rigidmol-optimizer 
# abcluster uses OpenMP. Use all available CPU, unless OMP_NUM_THREADS is specified.
##########################################################################################
function program_ABC {
  input=$1                             # $name.inp
  output=$(basename $input .inp).out   # $name.out
 
  #path to the script
  rigidmoloptimizer=$PATH_ABCluster
 
  #performing the calculation 
  #module load gcc/8.2.0 2>/dev/null
  module load gcc 2>/dev/null
  $rigidmoloptimizer $input > $output 
}
##########################################################################################
##########################################################################################
# Python
##########################################################################################
#use python2.X, numpy might be required (needed by JKCS1)
function program_PYTHON2 {
  #module load python-env/2.7.13 > /dev/null 2>/dev/null
  python2.7 ${@}
}
#use python3.X (needed by GoodVibes)
function program_PYTHON3 {
  #module load python-env/3.5.3 > /dev/null 2>/dev/null
  python3.6 ${@}
}
##########################################################################################
##########################################################################################
# sbatch
# command: sbatch [some_parameters] $SBATCHuseradd script
##########################################################################################
SBATCHuseradd=" --account=hvehkama "
##########################################################################################
##########################################################################################
# GoodVibes
# require python3.x
##########################################################################################
function program_GoodVibes {
  program_PYTHON2 $PATH_GoodVibes ${@}
}
##########################################################################################
##########################################################################################
# GNF2-xTB script: xtb
# xtb uses OMP parallelization. Use all available CPU, unless OMP_NUM_THREADS is specified.
##########################################################################################
function program_XTB {
  base="$(basename $1 .xyz)"   # file basename
  input="$( cd "$(dirname "$1")" ; pwd -P )""/${base}.xyz" # full path of file.xyz    
  output=$base.log             # file.log
  args=${@:2}                  # all arguments except the first one
  
  #load JKCS arguments
  if [ -e ../arguments.txt ]
  then
    source ../arguments.txt
  fi

  export XTBPATH=$PATH_XTB
  export PATH=$PATH:${XTBPATH}/bin:${XTBPATH}/scripts
  
  #CREATING WORKING DIRECTORY
  if [ ! -d $WRKDIR/TMP ]; then mkdir $WRKDIR/TMP; fi
  ADD=""
  test=0
  while [ $test -eq 0 ]
  do
    CALC_NAME=$WRKDIR/TMP/XTB${SLURM_JOBID}${ADD}
    if [ -d $CALC_NAME ]; then ADD="_${RANDOM}"
    else test=1;fi     
  done

  #TEMPERATURE
  next=0;method_help="";args_help="";
  for i in $method
  do 
    if [ "$i" == "-temp" ]; then next=1;continue;fi
    if [ "$next" == "1" ]; then next=2;TEMP=$i;continue;fi 
    method_help+=" $i"
  done
  method=$method_help
  for i in $args
  do 
    if [ "$i" == "-temp" ]; then next=1;continue;fi
    if [ "$next" == "1" ]; then next=2;TEMP=$i;continue;fi 
    args_help+=" $i"
  done
  args=$args_help

  #CHARGE AND MULTIPLICITY
  if [[ "$method" != *"-c "* ]] && [[ "$method" != *"-chrg "* ]] && [[ "$args" != *"-c "* ]] && [[ "$args" != *"-chrg "* ]];
  then
    if [ -z "$CHARGE" ]; then CHARGE=0; fi
    args+=" --chrg $CHARGE "
  fi
  if [[ "$method" != *"-u "* ]] && [[ "$method" != *"-uhf "* ]] && [[ "$args" != *"-u "* ]] && [[ "$args" != *"-uhf "* ]];
  then
    if [ -z "$MULTIPLICITY" ]; then MULTIPLICITY=1; fi
    unpaired=`echo $MULTIPLICITY-1|bc` 
    args+=" --uhf $unpaired "
  fi

  #ENTERING TO WORKING DIRECTORY AND PERFORMING CALCULATION
  DIR=$PWD
  mkdir $CALC_NAME
  cd $CALC_NAME
  cp $input calc.xyz
  if [ $next -eq 2 ]; then echo \$thermo >> calc.xyz; echo "    temp=$TEMP" >> calc.xyz; fi

  $XTBPATH/bin/xtb calc.xyz $method $args > $output 2>&1

  #COPYING RESULTS BACK
  cp $output $DIR/$output
  if [ -e xtbopt.xyz ]					      
  then								 
    cp xtbopt.xyz $DIR/$base.xyz				     
  else							     
    cp calc.xyz $DIR/$base.xyz
  fi  

  #CLEANING
  cd $DIR
  rm -rf $CALC_NAME
}
##########################################################################################
##########################################################################################
# G16 script: gaussian
# loadinng gaussian licence might be required
##########################################################################################
function program_G16 {
  input=$1                        # file.xyz or .com
  base=$(basename $(basename $input .xyz) .com)   # file
  inputCOM=$base.com
  output=$base.log             # file.log
  args=${@:2}                  # all arguments except the first one

  #load JKCS arguments
  if [ -e ../arguments.txt ]
  then
    source ../arguments.txt
  fi

  #source $PATH_G16/g16/bsd/g16.login
  export OMP_NUM_THREADS=1
  module load gaussian 2>/dev/null
 
  #CREATING WORKING DIRECTORY
  if [ ! -d $WRKDIR/TMP ]; then mkdir $WRKDIR/TMP; fi
  ADD=""
  test=0
  while [ $test -eq 0 ]
  do
    CALC_NAME=$WRKDIR/TMP/G16${SLURM_JOBID}${ADD}
    if [ -d $CALC_NAME ]; then ADD="_${RANDOM}"
    else test=1;fi
  done

  #ENTERING TO WORKING DIRECTORY AND PERFORMING CALCULATION
  DIR=$PWD
  #*.com or *.xyz
  test=`echo $input | rev | cut -c-4 | rev`
  if [ "$test" == ".xyz" ]
  then
    if [ -z "$method" ]
    then 
      JKxyz2com $input $args
    else
      JKxyz2com $input -method "$method" -mem $MEMORY -cpu $CPU -char $CHARGE -mult $MULTIPLICITY  $args
    fi
  else
    inputtest="$( cd "$(dirname "$1")" ; pwd -P )""/${base}.com"
    if [ $inputtest != $DIR/$inputCOM ]
    then
      cp $inputtest $DIR/$inputCOM
    fi
  fi
  #dirs
  mkdir $CALC_NAME
  cp $inputCOM $CALC_NAME/
  cd $CALC_NAME

  #echo JKxyz2com $input -method "$method" -mem $MEMORY -cpu $CPU -char $CHARGE -mult $MULTIPLICITY  $args 
  $PATH_G16/g16/g16 < $inputCOM >& $output

  #COPYING RESULTS BACK
  if [ -e $DIR/$output ]
  then
    mv $DIR/$output $DIR/${base}O.log
  fi
  cp $output $DIR/
  cd $DIR
  JKlog2xyz $output > /dev/null 2>/dev/null

  #CLEANING
  rm -rf $CALC_NAME
}
##########################################################################################
##########################################################################################
# ORCA script: orca
# 
##########################################################################################
function program_ORCA {
  input=$1                     # file.xyz or .inp    
  base=$(basename $input .xyz) # file
  base=$(basename $base .inp) # file
  inputINP=$base.inp
  output=$base.out             # file.out
  args=${@:2}                  # all arguments except the first one

  #load JKCS arguments
  if [ -e ../arguments.txt ]
  then
    source ../arguments.txt
  fi

  export OMP_NUM_THREADS=1 
  module load orca-env/4.0.1.2 2> /dev/null

  #CREATING WORKING DIRECTORY
  if [ ! -d $WRKDIR/TMP ]; then mkdir $WRKDIR/TMP; fi
  ADD=""
  test=0
  while [ $test -eq 0 ]
  do
    CALC_NAME=$WRKDIR/TMP/ORCA${SLURM_JOBID}${ADD}
    if [ -d $CALC_NAME ]; then ADD="_${RANDOM}"
    else test=1;fi
  done

  #ENTERING TO WORKING DIRECTORY AND PERFORMING CALCULATION
  DIR=$PWD
  mkdir $CALC_NAME
  #*.inp or *.xyz
  test=`echo $input | rev | cut -c-4 | rev`
  if [ "$test" == ".xyz" ]
  then
    if [ -z "$MEMORY" ]; then MEMORY=4000mb; fi
    MEMinsert=`echo 0.85*$MEMORY | sed 's/mb//' | sed 's/gb/*1000/' | bc`
    JKxyz2inp $input -method "$method" -mem $MEMORYinsert -cpu $CPU -char $CHARGE -mult $MULTIPLICITY  $args
    cp $inputINP $CALC_NAME/
  fi
  cp $input $CALC_NAME/
  cd $CALC_NAME  
 
  $PATH_ORCA $inputINP > $output 2> $output
  #JKout2xyz $output

  #COPYING RESULTS BACK
  cp $output $DIR/
  if [ ! -z "`ls *.xyz 2> /dev/null`" ] 
  then
    cp *.xyz $DIR/
  fi
  cd $DIR

  #CLEANING
  rm -rf $CALC_NAME
}
##########################################################################################
